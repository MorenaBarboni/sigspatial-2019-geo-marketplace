""" Crypto primitives

Note:
    - 2 PRFs are HMAC-SHA256 and AES-CMAC
"""

import os
from cryptography.fernet import Fernet
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import cmac, hmac, hashes, padding
from cryptography.hazmat.primitives.ciphers import algorithms, Cipher, modes, BlockCipherAlgorithm
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

BYTE_ORDER = 'big'
DEFAULT_SALT_LENGTH_IN_BYTES = 16
CMAC_AES128_KEY_LENGTH_IN_BYTES = 16
CMAC_AES128_BLOCK_SIZE = 16 * 8
HMAC_SHA256_KEY_LENGTH_IN_BYTES = 32
DEFAULT_NUM_ITERATIONS = 100000


def random_secure(length: int) -> bytes:
    """
    Generating random data for use in cryptographic operations
    :param length: number of bytes to generate
    :return: random data
    """
    return os.urandom(length)


def gen_symmetric_key() -> bytes:
    """
    Generate symmetric key for encryption using Fernet module
    :return: A URL-safe base64-encoded 32-byte key. This MUST be kept secret.
        Anyone with this key is able to create and read messages.
    """
    return Fernet.generate_key()


def encrypt_symmetric(key: bytes, message: bytes) -> bytes:
    """
    Encrypt message with symmetric key using Fernet module.
    The result of this encryption is known as a “Fernet token” and has strong privacy and authenticity guarantees.
    :param bytes key: Fernet symmetric key
    :param bytes message: message to encrypt
    :return: A secure message that cannot be read or altered without the key.
        It is URL-safe base64-encoded. This is referred to as a “Fernet token”.
    """
    return Fernet(key).encrypt(message)


def decrypt_symmetric(key: bytes, token: bytes) -> bytes:
    """
    Decrypts a Fernet token.
    If successfully decrypted you will receive the original plaintext as the result,
    otherwise an exception will be raised.
    It is safe to use this data immediately
    as Fernet verifies that the data has not been tampered with prior to returning it.
    :param bytes key: Fernet symmetric key
    :param bytes token: The Fernet token. This is the result of calling encrypt_symmetric().
    :return: The original plaintext.
    """
    return Fernet(key).decrypt(token)


def cal_cmac_aes(key: bytes, message: bytes) -> bytes:
    """
    Calculate CMAC with AES-128
    :param bytes key: 128-bit length key
    :param bytes message: message
    :return: CMAC code
    """
    c = cmac.CMAC(algorithms.AES(key), backend=default_backend())
    c.update(message)
    return c.finalize()


def cal_cmac_algorithm(algorithm: BlockCipherAlgorithm, message: bytes) -> bytes:
    """
    Calculate CMAC with a given block cipher algorithm
    :param BlockCipherAlgorithm algorithm: the algorithm to use
    :param bytes message: message
    :return: CMAC code
    """
    c = cmac.CMAC(algorithm, backend=default_backend())
    c.update(message)
    return c.finalize()


def encrypt_aes(key: bytes, iv: bytes, message: bytes) -> bytes:
    """
    Encrypt a message using AES
    :param key: AES key
    :param iv: AES IV
    :param message: message
    :return: cipher text
    """
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(pad_aes(message)) + encryptor.finalize()


def decrypt_aes(key: bytes, iv: bytes, ciphertext: bytes) -> bytes:
    """
    Decrypt a message using AES
    :param key: AES key
    :param iv: AES IV
    :param ciphertext:  ciphertext
    :return: decrypted message
    """
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    return unpad_aes(decryptor.update(ciphertext) + decryptor.finalize())


def pad_aes(message: bytes, blocksize=CMAC_AES128_BLOCK_SIZE) -> bytes:
    """
    Padding for AES CMAC
    :param message: message to pad
    :param blocksize: blocksize
    :return: padded message
    """
    padder = padding.PKCS7(blocksize).padder()
    padded_data = padder.update(message)
    return padded_data + padder.finalize()


def unpad_aes(message: bytes, blocksize=CMAC_AES128_BLOCK_SIZE) -> bytes:
    """
    Unpadding for AES CMAC
    :param message: message to unpad
    :param blocksize: blocksize
    :return: unpadded message
    """
    unpadder = padding.PKCS7(blocksize).unpadder()
    data = unpadder.update(message)
    return data + unpadder.finalize()


def cal_hmac_sha256(key: bytes, message: bytes) -> bytes:
    """
    Calculate HMAC code with SHA256

    The key should be randomly generated bytes and
    is recommended to be equal in length to the `digest_size` of the hash function chosen
    (which 256-bit in this case)
    You must keep the key secret.

    This is an implementation of RFC 2104.
    :param bytes key: hmac key
    :param bytes message: message to calcuate HMAC on
    :return:
    """
    h = hmac.HMAC(key, hashes.SHA256(), backend=default_backend())
    h.update(message)
    return h.finalize()


def hash_sha256(message: bytes) -> bytes:
    """
    Calculate SHA256 hash of a message
    :param message: the message
    :return: the hash
    """
    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(message)
    return digest.finalize()


def derive_password_based_key(password: bytes, salt: bytes, length=32, iterations=100000) -> bytes:
    """
    Derive a password-based key.

    User may want to later use `base64.urlsafe_b64encode` to store the key

    :param password: password
    :param salt: salt
    :param length: key length
    :param iterations: number of iterations
    :return: the derived key
    """
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=length,
        salt=salt,
        iterations=iterations,
        backend=default_backend()
    )
    return kdf.derive(password)


def convert_int_to_bytes(x: int) -> bytes:
    """
    Convert an int to bytes
    :param x: int value
    :return: bytes value
    """
    return x.to_bytes(length=(x.bit_length() + 7) // 8, byteorder=BYTE_ORDER)


def convert_int_from_bytes(xbytes: bytes) -> int:
    """
    Convert bytes to an integer
    :param xbytes: bytes value
    :return: int value
    """
    return int.from_bytes(bytes=xbytes, byteorder=BYTE_ORDER)


def convert_to_bytes(value) -> bytes:
    """
    Convert a value of `int` or `str` to bytes
    :param value: a value of `int` or `str`
    :return: bytes value
    :raise: TypeError if value is not int nor str
    """
    if isinstance(value, int):
        return convert_int_to_bytes(value)
    elif isinstance(value, str):
        return value.encode()
    else:
        raise TypeError("Value must be int or str")
